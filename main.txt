from hub import motion_sensor, port, button, light_matrix, light
import motor, runloop, motor_pair, color_sensor, color, time
from app import linegraph

motor_pair.pair(motor_pair.PAIR_1, port.C,port.D) # Pairs motors

linegraph.clear_all()

# Gyro and wheel motor
motion_sensor.reset_yaw(0)
motor.reset_relative_position(port.C, 0)

MIN_TURN = 100

wheel = 15.5 #cm (wheel circumference)

def difference(difference): # Calculates shortest way to wanted angle
    while difference > 180:
        difference -= 360
    while difference < -180:
        difference += 360
    return difference

def yaw(): # returns yaw angle
    return int(motion_sensor.tilt_angles()[0]*-0.1)

def relative(): # returns average relative travelled distance of both motors
    relative = int(((abs(motor.relative_position(port.C)))+(abs(motor.relative_position(port.D))))/2)
    return relative
"""
async def drive(cm, angle, maxspeed = 900):
    motor.reset_relative_position(port.C, 0)
    motor.reset_relative_position(port.D, 0)
    distance = int(cm / wheel * 360)-round(maxspeed/70)
    while relative() < distance:
        curyaw = yaw()
        togo = distance - relative()
        speed = max(int(maxspeed*togo/distance*3), 350)
        error = (difference(angle - curyaw))
        correction = min(90, max(-90, error))
        motor_pair.move(motor_pair.PAIR_1, correction, velocity= speed, acceleration= 950)
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)
    """
#Gyro forward drive in cm
async def drive(cm, angle, maxspeed = 900): # takes inputs: distance (cm), direction (from -180 to 180)
    motor.reset_relative_position(port.C, 0) #resets motors for distance measuring
    motor.reset_relative_position(port.D, 0)
    reverse = cm < 0
    distance = int(abs(cm) / wheel * 360)-round(maxspeed/70) # converts distance in centimeters to motor degrees
    print(distance)
    gain = 8
    while abs(relative()) < distance: # drives until distance reached
        curyaw = yaw()
        togo = distance - abs(relative())
        error = (difference(angle - curyaw))*gain # calculates difference between wished and current angle
        speed = max(int(maxspeed*togo/distance*2), 150)
        if reverse:
            motor_pair.move_tank(motor_pair.PAIR_1, -speed+error, -speed-error, acceleration=980) # corrects the run according to calculations, but drives in reverse
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, speed+error, speed-error, acceleration=980) # corrects the run according to calculations
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)

async def turn(angle, maxspeed = 1110):
    Kp, Ki, Kd = 4.5, 0.001, 1.2
    P, I, D, last = 0, 0 , 0, 0
    delay = 5
    while abs(yaw() - angle) > 1:
        curyaw = yaw()
        P = difference(angle - curyaw)
        I += P*delay
        D = (P - last)/delay
        speed = max(MIN_TURN, min(maxspeed, round(abs(P*Kp) + I*Ki + D*Kd)))
        if P > 0: # if degrees are negative, turns left; if degrees positive, turns right
            motor_pair.move_tank(motor_pair.PAIR_1, speed, -int(speed*1.05))
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, -int(speed*1.05), speed)
        last = P
        time.sleep_ms(delay)        
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)
    time.sleep_ms(250)

"""
#Gyro turning
async def turn(angle): # takes input: wished angle (-180 to 180)
    start_time = time.ticks_ms()
    while abs(yaw() - angle) > 1: # turns until wished angle is reached
        elapsed_time = time.ticks_diff(time.ticks_ms(), start_time) / 1000
        curyaw = yaw()
        error = difference(angle - curyaw) # calculates the amount of degree to be turned
        speed = calculate_speed(error)
        if error > 0: # kui kraadid on negatiivsed, pöörab vasakule, kui positiivsed pöörab paremale - if degrees are negative, turns left; if degrees positive, turns right
            motor_pair.move_tank(motor_pair.PAIR_1, speed, -int(speed*1.05))
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, -int(speed*1.05), speed)
        time.sleep_ms(10)
        linegraph.plot(color.RED, elapsed_time, speed)
        linegraph.plot(color.BLUE, elapsed_time, error)
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)
    time.sleep_ms(250) # stabiliseerib nt missiooni tegemiseks - stabilizes, for example: for solving missions
    linegraph.show(True
"""

async def bluerun():
    motor.run_for_degrees(port.E, 1080, 300, acceleration= 950, deceleration= 950)
    motor.run_for_degrees(port.F, 1080, 300, acceleration= 950, deceleration= 950)
    await turn(50)

def nupp(): # returns True, when one of the arrow buttons pressed
    return button.pressed(button.LEFT) or button.pressed(button.RIGHT)

async def main():
    #resets the gyro for start
    motion_sensor.reset_yaw(0)
    time.sleep_ms(1000)
    light_matrix.write("?")
    last_color = color.UNKNOWN
    color_actions = {
        color.BLUE: bluerun,
        #color.RED: redrun,# Add other colors as needed
    }
    #Here begins the mission code
    while True:
        current_color = color_sensor.color(port.B)
        # Check if color changed
        if current_color != last_color:
            last_color = current_color
            if current_color == color.UNKNOWN:
                light.color(light.POWER, color.BLACK)
                light.color(light.CONNECT, color.BLACK)
            else:
                # Update lights for the detected color
                light.color(light.POWER, current_color)
                light.color(light.CONNECT, current_color)

        # Trigger action if button is pressed and color is detected
        if nupp() and current_color in color_actions:
            await color_actions[current_color]()# Trigger the corresponding action

        # Handle UNKNOWN color (if needed)
        if current_color == color.UNKNOWN:
            if abs(difference(0 - motor.absolute_position(port.E))) >= 2 or abs(difference(0 - motor.absolute_position(port.F))) >= 2:
                motor.run_to_absolute_position(port.F, 0, 1050)
                await motor.run_to_absolute_position(port.E, 0, 1050)
            if nupp():
                light_matrix.write(str(hub.temperature()))

runloop.run(main())