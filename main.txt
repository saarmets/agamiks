"""
SPIKE 3 Python Code for FIRST LEGO League Team 'Aga Miks?'

This program controls the Agamiksmasin 2.0 for the FLL 2024-2025 SUBMERGED season.
Features:
    - Proportional-integral (PI) controlled drive function
    - Proportional-integral-derivative (PID) controlled turn function
    - Color-based autonomous mission selection
    - Inertia compensation (robot adaptive version in works)

Instagram: @agamiksfll
"""

from hub import motion_sensor, port, button, light_matrix, light, sound
import motor, runloop, motor_pair, color_sensor, color, time

motor_pair.pair(motor_pair.PAIR_1, port.C,port.D) # Pairs motors

MIN_TURN = 100
MIN_DRIVE = 200

wheel = 15.5 #cm (wheel circumference)

def difference(difference): # Calculates shortest way to wanted angle
    while difference > 180:
        difference -= 360
    while difference < -180:
        difference += 360
    return difference

def yaw(): # returns yaw angle in same format as app
    return round(motion_sensor.tilt_angles()[0]*-0.1)

def relative(): # returns average relative travelled distance of both motors
    relative = int(((abs(motor.relative_position(port.C)))+(abs(motor.relative_position(port.D))))/2)
    return relative

# Proportional Integral forward drive function
async def drive(cm, angle, maxspeed = 1110): # takes inputs: distance (cm), direction (from -180 to 180) and optional speedcap
    motor.reset_relative_position(port.C, 0) #resets motors for distance measuring
    motor.reset_relative_position(port.D, 0)
    reverse = cm < 0
    if abs(cm) < 15: maxspeed = 600 # limited speed for short distances to improve distance accuracy
    distance = int(abs(cm) / wheel * 360)-round(maxspeed/70) # converts distance in centimeters to motor degrees and deducts predicted inertia
    Kp, Ki = 8.5, 0.005
    I = 0
    while abs(relative()) < distance: # drives until distance reached
        curyaw = yaw()
        togo = distance - abs(relative())
        error = (difference(angle - curyaw)) # calculates difference between wished and current angle
        I += error
        correction = round(error * Kp + I * Ki) # correction calculation by the PI controller
        speed = max(int(maxspeed*togo/distance*2), MIN_DRIVE) # proportional speed to distance to combat the chonky robot's inertia
        if reverse:
            motor_pair.move_tank(motor_pair.PAIR_1, -speed+correction, -speed-correction, acceleration=980) # corrects the run according to calculations, but drives in reverse
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, speed+correction, speed-correction, acceleration=980) # corrects the run according to calculations
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)
    time.sleep_ms(250)

# Proportional–integral–derivative controlled turn function
async def turn(angle, maxspeed = 1110, temper = 1.0):
    Kp, Ki, Kd = 4.5*temper, 0.001*temper, 1.2*temper # PID constants for turning, temper as a gain for heavy attachments
    P, I, D, last = 0, 0 , 0, 0
    delay = 5
    while abs(yaw() - angle) > 1:
        curyaw = yaw()
        P = difference(angle - curyaw) # calculates difference between wished and current angle for proportional correction
        I += P*delay
        D = (P - last)/delay
        speed = max(MIN_TURN, min(maxspeed, round(abs(P*Kp) + I*Ki + D*Kd))) # PID controlled turning speed for extremely precise turns
        if P > 0: # if degrees are negative, turns left; if degrees positive, turns right
            motor_pair.move_tank(motor_pair.PAIR_1, speed, -int(speed*1.06)) # hub is offset from the axle, so the inner wheel is sped up to avoid arc turning
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, -int(speed*1.06), speed)
        last = P
        time.sleep_ms(delay)
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)
    time.sleep_ms(250)

async def bluerun():
    motion_sensor.reset_yaw(0)

async def redrun():
    motion_sensor.reset_yaw(0)
    time.sleep_ms(500)
    await drive(10, 0)
    motor.run_for_degrees(port.E, -450, 1050, deceleration= 950)
    await turn(-40)
    await drive(30, -40)
    await turn(0)
    await drive(28, 0)
    await turn(-45)
    await drive(14, -45)
    await motor.run_for_degrees(port.E, 500, 1050)
    motor.run_for_degrees(port.F, 150, 1050)
    await motor.run_for_degrees(port.E, 300, 1050)
    time.sleep_ms(1000)
    await motor.run_for_degrees(port.E, 300, -600, deceleration=950)
    motor.run_for_degrees(port.E, 300, 400, deceleration=950)
    await drive(-15, -45)
    await turn(-10)
    await drive(-65, -10)

async def yellowrun():
    motion_sensor.reset_yaw(0)
    time.sleep_ms(500)
    await turn(-65)
    await drive(57, -65)
    await turn(0, 300)
    motor.run_for_degrees(port.F, -130, 300, acceleration= 950, deceleration= 950)
    await drive(25, 0, 200)
    await drive(-10, 0)
    await motor.run_for_degrees(port.F, -400, 300, acceleration= 950, deceleration= 950)
    await turn(90)
    await drive(-50, 90)
    await motor.run_for_degrees(port.E, -400, 300, acceleration= 950, deceleration= 950)
    await motor.run_for_degrees(port.F, -200, 900, acceleration= 950, deceleration= 950)
    await drive(55, 90)
    await turn(120)
    await drive(35, 120)
    await turn(180)

async def greenrun():
    motion_sensor.reset_yaw(0)
    time.sleep_ms(500)
    await turn(45)
    await drive(45, 45)
    await turn(0)
    await drive(28, 0)
    await turn(-90)
    await drive(10, -90)
    await motor.run_for_degrees(port.F, 900, -600, acceleration= 950, deceleration= 950)
    await drive(-10,-90)
    await turn(-155)
    await drive(60, -155)

async def magentarun():
    motion_sensor.reset_yaw(0)
    time.sleep_ms(500)
    await drive(15, 0)
    await turn(-25)
    await drive(51, -25)
    await turn(45)
    await drive(22.5, 45)
    await motor.run_for_degrees(port.F, 350, 1050)
    time.sleep_ms(500)
    await motor.run_for_degrees(port.F, -350, 1050)
    await drive(-20, 45)
    await turn(120)
    await drive(-45, 120)
    await motor.run_for_degrees(port.E, -800, 800)
    await motor.run_for_degrees(port.E, 150, 1050)
    await drive(-15, 135)
    time.sleep_ms(3000)
    await drive(5, 135)

async def azurerun():
    motion_sensor.reset_yaw(0)
    time.sleep_ms(500)
    motor.run_for_degrees(port.E, 1080, 300, acceleration= 950, deceleration= 950)
    motor.run_for_degrees(port.F, 1080, 300, acceleration= 950, deceleration= 950)
    await turn(50)

async def blackrun():
    motion_sensor.reset_yaw(0)
    motor.reset_relative_position(port.F, 0)
    motor.reset_relative_position(port.E, 0)
    time.sleep_ms(500)
    await drive(12, 0) # Drive to unknown creature and push it then drive back to base
    motor.run_for_degrees(port.F, 550, 1050)
    await turn(-45, 700, 1.1)
    await drive(40, -45)
    await drive(-23, -45)
    await turn(0, 700, 1.1)
    await motor.run_for_degrees(port.F, 350, -1050)
    await drive(31, 0)
    await motor.run_for_degrees(port.F, 1700, 1050)
    await motor.run_for_degrees(port.F, 350, -1050)
    await turn(-15, 700, 1.1)
    await motor.run_for_degrees(port.F, 550, 1050)
    await drive(3, -15, 600)
    await turn(-65, 700, 1.1)
    await motor.run_for_degrees(port.F, 1000, -1050)
    await drive(20, -65)
    await turn(-80, 700, 1.1)
    motor.run_for_degrees(port.F, 550, -1050)
    await drive(45, -80)
    await drive(-3, -80)
    await motor.run_for_degrees(port.F, 700, 1050)
    await drive(6, -80)
    await motor.run_for_degrees(port.F, 700, 1050)
    await motor.run_for_degrees(port.F, 150, -1050)
    await turn(-90, 700, 1.1)
    await drive(24, -90)
    await motor.run_for_degrees(port.F, 1100, -1050)
    await drive(15, -90)
    await turn(-135, 700, 1.1)
    motor.run_for_degrees(port.F, 600, 600)
    await drive(80, -135)

async def whiterun():
    motion_sensor.reset_yaw(0)
    time.sleep_ms(500)
    motor.reset_relative_position(port.F, 0)
    motor.reset_relative_position(port.E, 0)
    motor.run_for_degrees(port.F, 100, -400, acceleration= 950, deceleration= 950)
    motor.run_for_degrees(port.E, 250, 1050)
    await drive(92, 0) # Drive the boat to destination
    await motor.run_for_degrees(port.E, 250, -1050)
    motor.run_for_degrees(port.E, 150, -1050)
    await drive(-21, 0, 600)
    await motor.run_for_degrees(port.E, 200, 1050)
    await turn(-45, 1110, 1.2)
    motor.run_for_degrees(port.E, 100, 1050)
    await drive(18, -45)
    await turn(0)
    await drive(110, 0)

def nupp(): # returns True, when one of the arrow buttons pressed
    return button.pressed(button.LEFT) or button.pressed(button.RIGHT)

async def main():
    #resets the gyro for start
    motion_sensor.reset_yaw(0)
    time.sleep_ms(1000)
    light_matrix.write("?")
    last_color = color.UNKNOWN
    color_runs = { # color database
        color.BLUE: bluerun,
        color.RED: redrun,
        color.GREEN: greenrun,
        color.YELLOW: yellowrun,
        color.AZURE: azurerun,
        color.MAGENTA: magentarun,
        color.BLACK: blackrun,
        color.WHITE: whiterun
    }
    while True:
        current_color = color_sensor.color(port.B)
        # check for color change
        if current_color != last_color:
            last_color = current_color
            if current_color == color.UNKNOWN:
                light.color(light.POWER, color.BLACK)
                light.color(light.CONNECT, color.BLACK)
            else:
                # update lights to corresponding color
                light.color(light.POWER, current_color)
                light.color(light.CONNECT, current_color)

        # start run with button press and tool color detection
        if nupp() and current_color in color_runs:
            sound.beep(440, 300) # beep to know that run has been activated
            await color_runs[current_color]()# trigger the corresponding run

        # handle UNKNOWN color (no attachments on robot)
        if current_color == color.UNKNOWN:
            if abs(difference(0 - motor.absolute_position(port.E))) >= 2 or abs(difference(0 - motor.absolute_position(port.F))) >= 2:
                motor.run_to_absolute_position(port.F, 0, 1050)
                await motor.run_to_absolute_position(port.E, 0, 1050)
            if nupp():
                light_matrix.write(str(hub.temperature()))

runloop.run(main())