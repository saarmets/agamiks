from hub import motion_sensor, port, button, light_matrix, light
import motor, runloop, motor_pair, color_sensor, color, time, math
from app import linegraph

motor_pair.pair(motor_pair.PAIR_1, port.C,port.D) # Pairs motors

linegraph.clear_all()


# Gyro and wheel motor
motion_sensor.reset_yaw(0)
motor.reset_relative_position(port.C, 0)

MIN_TURN = 100
MAX_TURN = 800

wheel = 15.5 #cm (wheel circumference)

def difference(difference): # Calculates shortest way to wanted angle
    while difference > 180:
        difference -= 360
    while difference < -180:
        difference += 360
    return difference

def yaw(): # returns yaw angle
    return int(motion_sensor.tilt_angles()[0]*-0.1)

def relative(): # returns average relative travelled distance of both motors
    relative = int(((abs(motor.relative_position(port.C)))+(motor.relative_position(port.D)))/2)
    return relative

def calculate_speed(angle_error):
        #Calculate speed based on angle error using exponential scaling
        max_speed = MAX_TURN
        min_speed = MIN_TURN
        scale_factor = 1 # make this value smaller for more agressive turns
        normalized_error = abs(angle_error) / 180
        speed = min_speed + (max_speed - min_speed) * (normalized_error ** scale_factor)
        return int(speed)

async def drive(cm, angle, maxspeed = 1110):
    motor.reset_relative_position(port.C, 0)
    motor.reset_relative_position(port.D, 0)
    distance = int(cm / wheel * 360)-round(maxspeed/50)
    P, I, D, last = 0, 0, 0, 0
    Kp = 1.5
    Ki = 0.001
    Kd = 0.5
    delay = 5
    while relative() < distance:
        curyaw = yaw()
        togo = distance - relative()
        speed = max(int(maxspeed*togo/distance*2), 250)
        P = (difference(angle - curyaw))
        I += P*delay
        D = (P - last)/delay
        correction = min(100, max(-100, int(P*Kp + I*Ki + D*Kd)))
        motor_pair.move(motor_pair.PAIR_1, correction, velocity= speed, acceleration= 950)
        last = P
        time.sleep_ms(delay)
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)

#Gyro turning
async def turn(angle): # takes input: wished angle (-180 to 180)
    start_time = time.ticks_ms()
    while abs(yaw() - angle) > 1: # turns until wished angle is reached
        elapsed_time = time.ticks_diff(time.ticks_ms(), start_time) / 1000
        curyaw = yaw()
        error = difference(angle - curyaw) # calculates the amount of degree to be turned
        speed = calculate_speed(error)
        if error > 0: # kui kraadid on negatiivsed, pöörab vasakule, kui positiivsed pöörab paremale - if degrees are negative, turns left; if degrees positive, turns right
            motor_pair.move_tank(motor_pair.PAIR_1, speed, -int(speed*1.05))
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, -int(speed*1.05), speed)
        time.sleep_ms(10)
        linegraph.plot(color.RED, elapsed_time, speed)
        linegraph.plot(color.BLUE, elapsed_time, error)
    motor_pair.stop(motor_pair.PAIR_1, stop = motor.SMART_BRAKE)
    time.sleep_ms(250) # stabiliseerib nt missiooni tegemiseks - stabilizes, for example: for solving missions
    linegraph.show(True)
async def bluerun():
    motor.run_for_degrees(port.E, 1080, 300, acceleration= 950, deceleration= 950)
    motor.run_for_degrees(port.F, 1080, 300, acceleration= 950, deceleration= 950)
    await turn(50)

def nupp(): # returns True, when one of the arrow buttons pressed
    return button.pressed(button.LEFT) or button.pressed(button.RIGHT)

async def main():
    #resets the gyro for start
    motion_sensor.reset_yaw(0)
    time.sleep_ms(1000)
    light_matrix.write("?")
    last_color = color.UNKNOWN
    #Here begins the mission code
    while True:
        current_color = color_sensor.color(port.B)
        if nupp():
            await bluerun()
        if current_color != last_color:
            last_color = current_color
            if current_color == color.GREEN:
                light.color(light.POWER, color.GREEN)
                light.color(light.CONNECT, color.GREEN)
            elif current_color == color.AZURE:
                light.color(light.POWER, color.AZURE)
                light.color(light.CONNECT, color.AZURE)
            elif current_color == color.YELLOW:
                light.color(light.POWER, color.YELLOW)
                light.color(light.CONNECT, color.YELLOW)
            elif current_color == color.MAGENTA:
                light.color(light.POWER, color.MAGENTA)
                light.color(light.CONNECT, color.MAGENTA)
            elif current_color == color.RED:
                light.color(light.POWER, color.RED)
                light.color(light.CONNECT, color.RED)
            elif current_color == color.WHITE:
                light.color(light.POWER, color.WHITE)
                light.color(light.CONNECT, color.WHITE)
            elif current_color == color.BLUE:
                light.color(light.POWER, color.BLUE)
                light.color(light.CONNECT, color.BLUE)
            if current_color == color.UNKNOWN:
                light.color(light.POWER, color.BLACK)
                light.color(light.CONNECT, color.BLACK)
                if abs(difference(0 - motor.absolute_position(port.E))) >= 2 or abs(difference(0 - motor.absolute_position(port.F))) >= 2:
                    motor.run_to_absolute_position(port.F, 0, 1050)
                    await motor.run_to_absolute_position(port.E, 0, 1050)
                if nupp():
                    light_matrix.write(str(hub.temperature()))

runloop.run(main())